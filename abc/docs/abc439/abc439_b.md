# ABC439 B（ハッピー数判定）: 実装で間違っていた点まとめ

対象: `b/401-500/abc439_b.c` の最初の実装

## 問題の要点

「各桁の二乗和に置き換える」を繰り返し、有限回で 1 になれば **Yes**、ならなければ **No**。
1 にならない場合はどこかで値がループするので、ループ検出（訪問済みチェック等）が必要。

## 間違っていた点

### 1) 桁を取り出すループ条件が逆

元コードでは概ね次の形になっていました。

```c
for (int i = 0; digit < 10; i++) {
    ...
}
```

- `digit` が 10 以上（例: 2026, 439）だと **最初からループに入らない**
- 結果として `cnt == 0` のままになり、後続の「桁の二乗和」を計算するループが空回りする

正しくは「`digit > 0` の間回す」か、`while (digit > 0)` のように書くのが自然。

### 2) 桁分解の式が誤っている

元コードでは

```c
A[i] = digit / 10;
digit = digit % 10;
```

のような処理で「各桁」を取ろうとしていましたが、これは **各桁を取り出せません**。

- 1 桁取り出すなら基本は `d = n % 10; n /= 10;`
- `/10` と `%10` の使い分けが逆方向で、値の更新もおかしくなる

### 3) 配列サイズが足りない

`A[3]` のようにしていると、最大 2026 は 4 桁なので **格納しきれず**、破壊的な不具合（未定義動作）につながります。

### 4) 「置き換え」を繰り返す処理になっていない

ハッピー数の判定は

- `N = sumsq_digits(N)` を毎回更新し
- 更新後の `N` を次のループでまた桁分解

という形で反復する必要があります。

元コードでは「最初に作った配列 `A[]` をずっと使っている」形になっており、
**置き換え後の値の桁**を計算していませんでした。

### 5) 二乗和の累積変数を毎回 0 に戻していない

二重ループ内で `happy += ...` と加算しているのに、
次のステップに進む前に `happy = 0;` に戻していないため、
「その回の二乗和」ではなく「ずっと足し続けた値」になってしまいます。

## 修正方針（今回の解法）

- `sumsq_digits(N)` を作り、`N = sumsq_digits(N)` を繰り返す
- `N == 1` になったら Yes
- 同じ `N` が再登場したらループなので No

制約 `N <= 2026` なので、訪問済み配列を使うのが簡単。

## 参考: 正しい桁二乗和

```c
static int sumsq_digits(int n) {
    int sum = 0;
    while (n > 0) {
        int d = n % 10;
        sum += d * d;
        n /= 10;
    }
    return sum;
}
```

## コード全文比較（Before / After）

### Before（最初の実装）

```c
#include <stdio.h>

int main(void) {
    // 入力
    int N;
    scanf("%d", &N);

    // Nの桁数を数える, 各桁の数字を配列に保存する
    int cnt = 0;
    int digit = N;
    int A[3];
    for (int i = 0; digit < 10; i++) {
        A[i] = digit / 10;
        digit = digit % 10;
        cnt++;
    }


    // ループを回す
    int happy = 0;
    for (int i = 0; i < 100; i++) {
        for (int j = 0; j < cnt; j++) {
            happy += A[j] * A[j];
        }
        if (happy == 1) {
            printf("Yes\n");
            return 0;
        }
    }

    printf("No\n");

    return 0;
}
```

### After（修正版）

```c
#include <stdio.h>

// 桁数を求める
static int sumsq_digits(int n) {
    int sum = 0;
    while (n > 0) {
        int d = n % 10;
        sum += d * d;
        n /= 10;
    }
    return sum;
}

int main(void) {
    int N;
    scanf("%d", &N);

    // 置き換えを繰り返し、同じ値に戻ったらループなので終了
    // 最初の N は最大 2026 なので、それを含む範囲を持っておく
    int seen[3000] = {0};
    while (1) {
        if (N == 1) {
            printf("Yes\n");
            return 0;
        }
        if (seen[N]) {
            printf("No\n");
            return 0;
        }
        seen[N] = 1;
        N = sumsq_digits(N);
    }

    return 0;
}
```

### 差分のポイント（要約）

- Before は「桁分解の条件・式・配列サイズ」が破綻しており、さらに「置き換え後の N を次の反復で再計算」できていません。
- After は `N = sumsq_digits(N)` を正しく反復し、`seen[]` でループ検出することで確実に Yes/No を判定します。
